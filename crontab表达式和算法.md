#crontab 表达式 语法

##表达式
*min hour day month week cmd*

crontab表达式描述的是时间集合 `*/1 * * * * ` 表示所有的分钟集合（0-59）都会执行

crontab表达式各个栏位范围如下：

| 字段名         | 是否必须      | 允许的值  |允许的特定字符  |
| :------------- |:----------- :| -----:|--------------:|
|分(Minutes)     |是	             |0-59	|   * / , -|
|时(Hours)	    |是	            |0-23	|* / , -|
|日(Day of month)|	是           |	1-31   |	* / , – ?|
|月(Month)	|是	|1-12 or JAN-DEC   |	* / , -|
|星期(Day of week)|	否	|0-6 or SUM-SAT|	* / , – ?|

先那分（min）这个栏位来说，我们用 int64 的二进制来标记分钟上的集合，从右往左第1位标识0分钟，第2位标记标识1分钟一直到第60位标记第59分钟.

用程序语言描述的话就是 第0分钟用 1<< 0 标识 第1分钟用 1<<1 标记 第59分钟就是 1<< 59。

###“/”符号

ok，照上面说的方法 我们如何表示 `*/1 * * * *` 分钟的所有集合呢？其实 “/”的右边表示集合范围，右边表示步长（step), 我们都可以用下面的算法算出他的标识方式

    for i := min; i <= max; i += step {
        bits |= 1 << i
    }

表示这个栏位最大的集合，上面的表达式

其实就是 1 << 0 | 1 <<1 | 1 <<2 ... 1<< 59 等同于 ^(MaxUint64 << 60) 等于

二进制 （ 111111111111111111111111111111111111111111111111111111111111）

那么同理 */2 * * * * 标识被2整除的集合就是 1<< 0 | 1<< 2 | 1<<4 .. 1<< 58 等于二进制

（010101010101010101010101010101010101010101010101010101010101）。

####补充说明下

crontab 表达式中 ‘/’ 后面的数值是步长（step) 可执行的时刻值可以理解为 *范围内除以 步长 余数为 0 的时刻*

例如` */7 * * * *`  crontab 在 并不是严格的每7分钟执行一次，他的二进制表示方法如下：

`000100000010000001000000100000010000001000000100000010000001`

从这个表达式中可以看出 */7 * * * * 他的执行分钟时刻为0 7 14 21 28 35 42 49 56 下一个执行时间是 下一个小时的 0分钟 （并不是下个小时的1分钟）

###“-“符号

“-”表示一个范围 2-9/2 * * * * 这种表达式 就是 2到9分钟 被2整除的所有集合 就是 2 4 6 8 表示为 1<<2 | 1 <<4 |1<< 6 | 1<< 8 同样它的标识方式时

    for i := 2; i <= 9; i += 2 {
        bits |= 1 << i
    }

###“,”符号

“,”表示枚举值 比如表达式 1,5,9 * * * * 他表示的时1分钟，5分钟和9分钟 1<< 1 | 1<< 5 | 1<<9

###“？”符合

“？”只用于 日(Day of month) 和 星期(Day of week)，表示不指定值，可以用于代替 *

##其它栏位标识方式
   *分钟的标识方式已经清楚了，其它的四个栏位标识方式和它一样，唯一有差别的时 栏位的集合范围，比如 分钟是 0-59 小时是 0-23*

   完整表达式 `“1-9/2 8-23 1,3,5 9 ?”` 最后这个表达式的标识方式如下:

       min   : 1010101010
       hour  : 111111111111111100000000
       day   : 101010
       month : 1000000000
       week  : 1111111

#任务时间排序和计算下次执行的时刻